請建立 Shape 類別，並在 Shape 中定義 getArea() 方法。
建立Rectangle 類別繼承 Shape，在 Rectangle 中覆寫該方法來計算面積。
最後，說明你的設計重點：
1. Shape為何要設計成抽象類別，如果不，會有甚麼問題:
另外，設計Main類別進行下列測試：
s 是Shape型態，是Rectangle物件，長寬分別是5，10
System.out.println("Area: " + s.getArea());

輸出：
Area: 50.0

---

## 設計重點說明

### 1. Shape為何要設計成抽象類別，如果不，會有甚麼問題：

**為什麼 Shape 必須是抽象類別：**

1. **概念上的抽象性**：
   - Shape（形狀）本身是一個抽象概念，現實中不存在「純粹的形狀」
   - 只存在具體的形狀，如矩形、圓形、三角形等
   - 抽象類別完美地表達了這種概念上的抽象性

2. **強制子類別實現**：
   - 每種具體形狀計算面積的方式都不同
   - 抽象方法 `getArea()` 強制所有子類別必須提供自己的實現
   - 確保多型性的正確運作

3. **防止不當實例化**：
   - 抽象類別無法被直接實例化
   - 避免 `new Shape()` 這種沒有意義的操作

**如果 Shape 不是抽象類別會有的問題：**

1. **實現困難**：
   - 普通類別必須提供 `getArea()` 的具體實現
   - 但 Shape 本身無法知道如何計算面積
   - 只能回傳 0 或拋出異常，都不是好的設計

2. **錯誤實例化**：
   - 允許 `new Shape()` 會創建沒有實際意義的物件
   - 違反了物件導向設計的邏輯性

3. **缺乏編譯時檢查**：
   - 子類別可能忘記覆寫 `getArea()` 方法
   - 會導致執行時的錯誤行為

4. **設計意圖不明確**：
   - 無法清楚表達 Shape 作為基類的抽象性質
   - 其他開發者可能誤用這個類別

**抽象類別的優勢：**
- 提供了完美的多型性支援：`Shape s = new Rectangle(5, 10)`
- 編譯時強制檢查：確保所有子類別都實現了必要方法
- 清晰的設計意圖：明確表示這是一個不能直接使用的抽象概念
- 程式碼安全性：防止邏輯錯誤和不當使用

**測試結果驗證：**
```
Area: 50.0
```
成功展示了多型性：透過 Shape 型態的變數呼叫 Rectangle 物件的 getArea() 方法。